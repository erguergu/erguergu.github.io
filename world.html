<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>The Sea</title>
		<link rel="shortcut icon" href="favicon.ico" />
		<link rel="stylesheet" type="text/css" href="main.css">
		<style>
			canvas {
				display: block;
				width: 100%;
				height: 100%;
			}

			#newWindow {
				display: block;
				position: absolute;
				bottom: 0.3em;
				left: 0.5em;
				color: #fff;
			}
		</style>
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "./scripts/build/three.module.js",
					"three/addons/": "./scripts/jsm/"
				}
			}
		</script>

		<script type="module">
			import {
				BoxGeometry,
                BufferAttribute,
				BufferGeometry,
				CapsuleGeometry,
				CircleGeometry,
				Color,
				DirectionalLight,
				DoubleSide,
				Float32BufferAttribute,
				Group,
				LineSegments,
				LineBasicMaterial,
				Mesh,
                MeshBasicMaterial,
				MeshPhongMaterial,
				PerspectiveCamera,
                PlaneGeometry,
                RepeatWrapping,
				Scene,
                SphereGeometry,
                TextureLoader,
				Vector2,
				Vector3,
				WireframeGeometry,
				WebGLRenderer
			} from 'three';

			import { GUI } from './scripts/jsm/lil-gui.module.min.js';
			import { OrbitControls } from './scripts/jsm/OrbitControls.js';
			import { Water } from 'three/addons/Water3d.js';

			const twoPi = Math.PI * 2;
            const worldRadius = 2000;

            let vertDist = 80;
            let onlyOnce = true;
            function getNearbyTriangles( ) {
                const mesh = world.children[ 1 ];

                // // Access the position attribute (vertices)
                // const position = geometry.attributes.position;
                // const vertexCount = position.count;

                const positionAttribute = mesh.geometry.attributes.position;
                const indexAttr = mesh.geometry.index.array;
                const vertexCount = indexAttr.length;

                if (onlyOnce) {
                    console.log(`positionAttribute`, positionAttribute);
                }
                const camWorld = new Vector3();
                camera.getWorldPosition(camWorld);
                const maxDist = vertDist;

                // loop through all the triangles in the sphere
                let t = 0;
	            for (let v = 0; v < vertexCount; v += 3) {
                    let isMatch = false;
                    let triangle = { index: t, verts: [], needsCreate: true, needsRemove: false, mesh: null, marker: null };

                    if (t > 1) {    
                        onlyOnce = false;
                    }
                    const v1 = new Vector3().fromBufferAttribute(positionAttribute, indexAttr[v]);
                    const wv1 = v1;
                    mesh.localToWorld(wv1);
                    triangle.verts.push(wv1);
                    if ( Math.abs(camWorld.distanceTo(wv1)) < maxDist ) {
                        isMatch = true;
                    }

                    const v2 = new Vector3().fromBufferAttribute(positionAttribute, indexAttr[v+1]);
                    const wv2 = v2;
                    mesh.localToWorld(wv2);
                    triangle.verts.push(wv2);
                    if ( Math.abs(camWorld.distanceTo(wv2)) < maxDist ) {
                        isMatch = true;
                    }

                    const v3 = new Vector3().fromBufferAttribute(positionAttribute, indexAttr[v+2]);
                    const wv3 = v3;
                    mesh.localToWorld(wv3);
                    triangle.verts.push(wv3);
                    if ( Math.abs(camWorld.distanceTo(wv3)) < maxDist ) {
                        isMatch = true;
                    }

                    // at this point, we have created vector3s for v to v+2, and added them
                    // to a triangle. we inspected each vertex and looked at its distance
                    // to the camera, if it's close, we set isMatch to true.
                    // Now, we will loop through the existing nearbytriangles array and
                    // see if any 
                    let alreadyNear = false;
                    for (let i = 0; i < nearbyTriangles.length; i++) {
                        const nearTri = nearbyTriangles[i];
                        if (nearTri.index == triangle.index) {
                            if (isMatch) {
                                // the triangle is nearby, but it's already
                                // in the nearbytriangles array
                                alreadyNear = true;
                            } else {    
                                // the triangle is in the nearbyTriangles array but
                                // it is no longer near.
                                nearTri.needsRemove = true;
                            }
                        }
                    }
                    if (isMatch && !alreadyNear) {
                        // add this triangle to the arrray if it's not already in it.
                        nearbyTriangles.push(triangle);
                    }
                    t++;
                }

                for (let i = nearbyTriangles.length - 1; i >= 0; i--) {
                    const tri = nearbyTriangles[i];
                    if (tri.needsRemove) {
                        nearbyTriangles.splice(i, 1);
                        removeTriangle(tri);
                    } else if (tri.needsCreate) {
                        drawTriangle(tri);
                    }
                }

                console.log(`Nearby triangles: ${nearbyTriangles.length}`);
            }

            function drawTriangle ( triangle ) {

                const v0 = triangle.verts[0];
                const v1 = triangle.verts[1];
                const v2 = triangle.verts[2];

                const avg = new Vector3();
                avg.add(v0);
                avg.add(v1);
                avg.add(v2);
                avg.divideScalar(3);
                const markerGeo = new SphereGeometry( 1, 8, 8 ); 
                const markerMat = new MeshBasicMaterial( { color: 0xff0000 } ); 
                const marker = new Mesh( markerGeo, markerMat ); 
                marker.position.set(avg.x, avg.y, avg.z);
                world.attach( marker );
                triangle.marker = marker;

                const geometry = new BufferGeometry();

                // create a simple triangle shape.
                const vertices = new Float32Array( [
                    v0.x, v0.y, v0.z, // v0
                    v1.x, v1.y, v1.z, // v1
                    v2.x, v2.y, v2.z, // v2
                ] );

                // need to set normals here

                // itemSize = 3 because there are 3 values (components) per vertex
                geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
                const material = new MeshPhongMaterial( { color: 0x156289, emissive: 0x072534, side: DoubleSide, flatShading: true } );
                const mesh = new Mesh( geometry, material );

                world.attach( mesh );
                triangle.mesh = mesh;
                triangle.needsCreate = false;
            }

            function removeTriangle ( triangle ) {
                triangle.mesh.geometry.dispose();
                triangle.mesh.material.dispose();
                triangle.marker.geometry.dispose();
                triangle.marker.material.dispose();
                triangle.mesh.removeFromParent();
                triangle.marker.removeFromParent();
            }

            function calculateSphericalCoordinatesOfNorthPole(sphere) {
                // Create a vector representing the north pole in local coordinates
                const localNorthPole = new Vector3(0, 1, 0);

                // Apply the sphere's world rotation to the local north pole vector
                const worldNorthPole = localNorthPole.clone().applyQuaternion(sphere.quaternion);

                // Now worldNorthPole contains the north pole position in world coordinates

                // Calculate radial distance from origin (r)
                const r = worldNorthPole.length();

                // Calculate theta (polar angle) - angle from the positive y-axis
                const theta = Math.acos(worldNorthPole.y / r);

                // Calculate phi (azimuthal angle) - angle around the y-axis from the positive z-axis
                const phi = Math.atan2(worldNorthPole.x, worldNorthPole.z);

                return { theta, phi };
            }


			function updateGroupGeometry( mesh, geometry ) {

				mesh.children[ 0 ].geometry.dispose();
				mesh.children[ 1 ].geometry.dispose();
                  
				mesh.children[ 0 ].geometry = new WireframeGeometry( geometry );
				mesh.children[ 1 ].geometry = geometry;

                for (let i = nearbyTriangles.length - 1; i >= 0; i--) {
                    const tri = nearbyTriangles[i];
                    nearbyTriangles.splice(i);
                    removeTriangle(tri);
                }


                console.log(`before - world children: ${world.children.length}`);
                getNearbyTriangles( );
                console.log(`after - world children: ${world.children.length}`);
			}

			const guis = {

                BoxSphere: function ( mesh ) {
                    const data = {
						radius: worldRadius,
						segments: 30,
                        distance: 120
					};

					function generateGeometry() {

                        vertDist = data.distance;
                        const boxSphereGeo =    new BoxGeometry(
								data.radius, data.radius, data.radius, data.segments, data.segments, data.segments
							);   
                        const positionAttribute = boxSphereGeo.attributes.position; 
                        // Modify vertices to make them equidistant from the center 
                        for (let i = 0; i < positionAttribute.count; i++) {
                            // Get vertex position
                            const x = positionAttribute.getX(i);
                            const y = positionAttribute.getY(i);
                            const z = positionAttribute.getZ(i);
                            // Calculate distance from the center
                            const length = Math.sqrt(x * x + y * y + z * z);
                            // Normalize and scale to the desired radius
                            const newX = (x / length) * data.radius;
                            const newY = (y / length) * data.radius;
                            const newZ = (z / length) * data.radius;
                            // Update vertex position
                            positionAttribute.setXYZ(i, newX, newY, newZ);
                        } 
                        // Recompute normals for shading
                        boxSphereGeo.computeVertexNormals();

                        
	                    const numTriangles = boxSphereGeo.index.count / 3; 
                        console.log(`This geometry has ${numTriangles} triangles.`);

						updateGroupGeometry( mesh, boxSphereGeo );

					}

					const folder = gui.addFolder( 'BoxSphere' );

					folder.add( data, 'radius', 1, worldRadius ).onChange( generateGeometry );
					folder.add( data, 'segments', 1, 200 ).step( 1 ).onChange( generateGeometry );
					folder.add( data, 'distance', 1, 2000 ).step( 1 ).onChange( generateGeometry );

					generateGeometry();

                }

			};

			function chooseFromHash( mesh ) {

				const selectedGeometry = window.location.hash.substring( 1 ) || 'BoxSphere';

				if ( guis[ selectedGeometry ] !== undefined ) {

					guis[ selectedGeometry ]( mesh );

				}

			}

			function createWater ( ) {
                const waterGeometry = new PlaneGeometry( 10000, 10000 );
                let water = new Water(
                    waterGeometry,
                    {
                        textureWidth: 512,
                        textureHeight: 512,
                        waterNormals: new TextureLoader().load( 'waternormals.jpg', function ( texture ) {
                            texture.wrapS = texture.wrapT = RepeatWrapping;
                        } ),
                        sunDirection: lights[ 0 ].position.clone().normalize(),
                        sunColor: 0xffffff,
                        waterColor: 0x000f1e,
                        distortionScale: 3.7,
                        size: 4.2,
                        fog: scene.fog !== undefined
                    }
                );
                water.rotation.x = - Math.PI / 2;
                water.position.y = worldRadius;
                scene.add( water );
            
                const waterUniforms = water.material.uniforms;
                const folderWater = gui.addFolder( 'Water' );
                folderWater.add( waterUniforms.distortionScale, 'value', 0, 8, 0.1 ).name( 'distortionScale' );
                folderWater.add( waterUniforms.size, 'value', 0.1, 10, 0.1 ).name( 'size' );
                folderWater.open();

                return water;
            }

			const selectedGeometry = window.location.hash.substring( 1 );

			if ( guis[ selectedGeometry ] !== undefined ) {

				document.getElementById( 'newWindow' ).href += '#' + selectedGeometry;

			}

			const gui = new GUI();

			const scene = new Scene();
			scene.background = new Color( 0x4444ff );

			const camera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1500 );
            camera.position.y = worldRadius + 1;

			const renderer = new WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			//const orbit = new OrbitControls( camera, renderer.domElement );

			const lights = [];
			lights[ 0 ] = new DirectionalLight( 0xffffff, 3 );
			//lights[ 1 ] = new DirectionalLight( 0xffffff, 3 );
			//lights[ 2 ] = new DirectionalLight( 0xffffff, 3 );

			lights[ 0 ].position.set( 200, worldRadius+40, 400 );
			//lights[ 1 ].position.set( 200, 400, 400 );
			//lights[ 2 ].position.set( - 200, - 400, - 200 );

			scene.add( lights[ 0 ] );
			//scene.add( lights[ 1 ] );
			//scene.add( lights[ 2 ] );


            //let water = createWater();

			const world = new Group();
            let nearbyTriangles = [];

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [], 3 ) );

			const lineMaterial = new LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );
			const meshMaterial = new MeshPhongMaterial( { color: 0x156289, emissive: 0x072534, side: DoubleSide, flatShading: true } );

			world.add( new LineSegments( geometry, lineMaterial ) );
			world.add( new Mesh( geometry, meshMaterial ) );
            world.children[ 1 ].visible = false;

			chooseFromHash( world );

			scene.add( world );

            const rotationSpeed = 0.00005;
            const upVector = new Vector3(0, 1, 0);
            const cameraDirection = new Vector3();
            let frameCount = -1;
			function render() {

                if (frameCount == -1) {
                    // okay gotta do some experimenting here because clearly I don't know what I'm doing
                    console.log(`world`, world.children[1]);
                }

				requestAnimationFrame( render );

				// Turn the camera if the user is turning:
                camera.rotation.y += dirRotate * 0.05;

                // Get the camera's forward direction in world space
                camera.getWorldDirection(cameraDirection);

                // Calculate the 'x' axis relative to the camera 'motion'
                const rotationAxis = new Vector3().crossVectors(cameraDirection, upVector).normalize();

                // Rotate the 'world' under the camera to give the impression of the
                // camera moving around the surface of the world.
                world.rotateOnWorldAxis(rotationAxis, rotationSpeed * dirMove);

                if (frameCount++ == 60) {
                    frameCount = 0;

                    if (dirMove != 0) {
                        //console.log(`Theta: ${sphericalCoords.theta}, Phi: ${sphericalCoords.phi}`);
                        getNearbyTriangles();
                    }
                }

                // water.material.uniforms[ 'time' ].value += 1.0 / 60.0;

				renderer.render( scene, camera );

			}

			window.addEventListener( 'resize', function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}, false );

            let dirRotate = 0;
            let dirMove = 1;
            window.addEventListener( 'keydown', function( e ) {
                if (e.code == 'ArrowLeft') {
                    dirRotate = 1;
                } else if (e.code == 'ArrowRight') {
                    dirRotate = -1;
                } else if (e.code == 'ArrowUp') {
                    dirMove = 1;
                } else if (e.code == 'ArrowDown') {
                    dirMove = -1;
                }
            });
            window.addEventListener( 'keyup', function( e ) {
                if (e.code == 'ArrowLeft' || e.code == 'ArrowRight') {
                    dirRotate = 0;
                } else if (e.code == 'ArrowUp' || e.code == 'ArrowDown') {
                    dirMove = 0;
                }
            });

			render();

		</script>
	</body>
</html>