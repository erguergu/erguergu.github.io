<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>The Sea</title>
		<link rel="shortcut icon" href="favicon.ico" />
		<link rel="stylesheet" type="text/css" href="main.css">
		<style>
			canvas {
				display: block;
				width: 100%;
				height: 100%;
			}

			#newWindow {
				display: block;
				position: absolute;
				bottom: 0.3em;
				left: 0.5em;
				color: #fff;
			}
		</style>
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "./scripts/build/three.module.js",
					"three/addons/": "./scripts/jsm/"
				}
			}
		</script>

		<script type="module">
			import {
				BoxGeometry,
                BufferAttribute,
				BufferGeometry,
				CapsuleGeometry,
				CircleGeometry,
				Color,
                CubeTextureLoader,
				DirectionalLight,
				DoubleSide,
				Float32BufferAttribute,
				Group,
				LineSegments,
				LineBasicMaterial,
				Mesh,
                MeshBasicMaterial,
				MeshPhongMaterial,
				PerspectiveCamera,
                PlaneGeometry,
                RepeatWrapping,
				Scene,
                SphereGeometry,
                TextureLoader,
				Vector2,
				Vector3,
				WireframeGeometry,
				WebGLRenderer
			} from 'three';

			import { GUI } from './scripts/jsm/lil-gui.module.min.js';
			import { OrbitControls } from './scripts/jsm/OrbitControls.js';
			import { Water } from './scripts/jsm/Water2.js';

			const twoPi = Math.PI * 2;
            const worldRadius = 5000;

            let vertDist = 80;
            let onlyOnce = true;
            function getNearbyTriangles( distortionScale, size ) {
                const mesh = world.children[ 1 ];

                // // Access the position attribute (vertices)
                // const position = geometry.attributes.position;
                // const vertexCount = position.count;

                const positionAttribute = mesh.geometry.attributes.position;
                const indexAttr = mesh.geometry.index.array;
                const vertexCount = indexAttr.length;

                if (onlyOnce) {
                    console.log(`positionAttribute`, positionAttribute);
                }
                const camWorld = new Vector3();
                camera.getWorldPosition(camWorld);
                const maxDist = vertDist;

                // loop through all the triangles in the sphere
                let t = 0;
	            for (let v = 0; v < vertexCount; v += 3) {
                    let isMatch = false;
                    let triangle = { index: t, verts: [], needsCreate: true, needsRemove: false, mesh: null, marker: null };

                    if (t > 1) {    
                        onlyOnce = false;
                    }
                    const v1 = new Vector3().fromBufferAttribute(positionAttribute, indexAttr[v]);
                    const wv1 = v1;
                    mesh.localToWorld(wv1);
                    triangle.verts.push(wv1);
                    if ( Math.abs(camWorld.distanceTo(wv1)) < maxDist ) {
                        isMatch = true;
                    }

                    const v2 = new Vector3().fromBufferAttribute(positionAttribute, indexAttr[v+1]);
                    const wv2 = v2;
                    mesh.localToWorld(wv2);
                    triangle.verts.push(wv2);
                    if ( Math.abs(camWorld.distanceTo(wv2)) < maxDist ) {
                        isMatch = true;
                    }

                    const v3 = new Vector3().fromBufferAttribute(positionAttribute, indexAttr[v+2]);
                    const wv3 = v3;
                    mesh.localToWorld(wv3);
                    triangle.verts.push(wv3);
                    if ( Math.abs(camWorld.distanceTo(wv3)) < maxDist ) {
                        isMatch = true;
                    }

                    // at this point, we have created vector3s for v to v+2, and added them
                    // to a triangle. we inspected each vertex and looked at its distance
                    // to the camera, if it's close, we set isMatch to true.
                    // Now, we will loop through the existing nearbytriangles array and
                    // see if any 
                    let alreadyNear = false;
                    for (let i = 0; i < nearbyTriangles.length; i++) {
                        const nearTri = nearbyTriangles[i];
                        if (nearTri.index == triangle.index) {
                            if (isMatch) {
                                // the triangle is nearby, but it's already
                                // in the nearbytriangles array
                                alreadyNear = true;
                            } else {    
                                // the triangle is in the nearbyTriangles array but
                                // it is no longer near.
                                nearTri.needsRemove = true;
                            }
                        }
                    }
                    if (isMatch && !alreadyNear) {
                        // add this triangle to the arrray if it's not already in it.
                        nearbyTriangles.push(triangle);
                    }
                    t++;
                }

                for (let i = nearbyTriangles.length - 1; i >= 0; i--) {
                    const tri = nearbyTriangles[i];
                    if (tri.needsRemove) {
                        nearbyTriangles.splice(i, 1);
                        removeTriangle(tri);
                    } else if (tri.needsCreate) {
                        drawTriangle(tri, distortionScale, size);
                    }
                }

                console.log(`Nearby triangles: ${nearbyTriangles.length}`);
            }

            function drawTriangle ( triangle, distortionScale, size ) {

                const v0 = triangle.verts[0];
                const v1 = triangle.verts[1];
                const v2 = triangle.verts[2];

                const avg = new Vector3();
                avg.add(v0);
                avg.add(v1);
                avg.add(v2);
                avg.divideScalar(3);
                const markerGeo = new SphereGeometry( 5, 8, 8 ); 
                const markerMat = new MeshPhongMaterial( { color: 0xff0000, emissive: 0x072534 } );
                const marker = new Mesh( markerGeo, markerMat ); 
                marker.position.set(avg.x, avg.y, avg.z);
                world.attach( marker );
                triangle.marker = marker;

                const geometry = new BufferGeometry();

                // create a simple triangle shape.
                const vertices = new Float32Array( [
                    v0.x, v0.y, v0.z, // v0
                    v1.x, v1.y, v1.z, // v1
                    v2.x, v2.y, v2.z, // v2
                ] );

                geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
				geometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( [0,1,1,1,0,0/*,1,1,1,0,0,0*/] ), 2 ));
                geometry.computeVertexNormals();
				const norms = geometry.getAttribute('normal');
				const firstNorm = new Vector3(norms.getX(0),norms.getY(0),norms.getZ(0));
                const params = {
                    color: '#ffffff',
                    scale: 4,
                    flowX: 1,
                    flowY: 1
                };
                let water = new Water(
                    geometry,
                    {
                        doRefraction: false,
                        color: params.color,
                        reflectivity: 1,
                        scale: params.scale,
                        flowDirection: new Vector2( params.flowX, params.flowY ),
                        textureWidth: 1024,
                        textureHeight: 1024,
                        normal: firstNorm
                    }
                );

                //world.attach( water );
                triangle.mesh = water;
                triangle.needsCreate = false;
            }

            const waterTileSize = 100;
            const waterTileCount = 3;
            const waterTiles = [];
            function initWaterTiles() {
                let i = 0;
                for (let x = 0; x < waterTileCount; x++) {
                    for (let z = 0; z < waterTileCount; z++) {
                        const from0x = x * waterTileSize;
                        const from0z = z * waterTileSize;
                        const totalDim = waterTileSize * waterTileCount;
                        const shiftedX = totalDim/2 - from0x;
                        const shiftedZ = totalDim/2 - from0z;

                        const water = drawWaterTile(i, shiftedX, 0, shiftedZ);
                        waterTiles.push(water);
                        i++;
                    }
                }
            }


            function drawWaterTile ( index, xPos, yPos, zPos ) {
                const minX = xPos - waterTileSize/2;
                const maxX = xPos + waterTileSize/2;
                const yVal = yPos;
                const minZ = zPos - waterTileSize/2;
                const maxZ = zPos + waterTileSize/2;
                const geometry = new BufferGeometry();
                const vertices = new Float32Array( [
                    minX, yVal, maxZ, // v0
                    maxX, yVal, maxZ, // v1
                    minX, yVal, minZ, // v2

                    maxX, yVal, maxZ,
                    maxX, yVal, minZ,
                    minX, yVal, minZ,
                ] );
                geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
				geometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( [0,1,1,1,0,0,1,1,1,0,0,0] ), 2 ));
                geometry.computeVertexNormals();
				const firstNorm = new Vector3(0,1,0);
                const params = {
                    color: '#ffffff',
                    scale: 4,
                    flowX: 1,
                    flowY: 1
                };
                let water = new Water(
                    geometry,
                    {
                        doRefraction: false,
                        color: params.color,
                        reflectivity: 1,
                        scale: params.scale,
                        flowDirection: new Vector2( params.flowX, params.flowY ),
                        textureWidth: 1024,
                        textureHeight: 1024,
                        normal: firstNorm
                    }
                );
                scene.attach(water);
                return water;
            }

            function removeTriangle ( triangle ) {
                triangle.marker.geometry.dispose();
                triangle.marker.material.dispose();
                triangle.marker.removeFromParent();

                triangle.mesh.dispose();
            }

            function calculateSphericalCoordinatesOfNorthPole(sphere) {
                // Create a vector representing the north pole in local coordinates
                const localNorthPole = new Vector3(0, 1, 0);

                // Apply the sphere's world rotation to the local north pole vector
                const worldNorthPole = localNorthPole.clone().applyQuaternion(sphere.quaternion);

                // Now worldNorthPole contains the north pole position in world coordinates

                // Calculate radial distance from origin (r)
                const r = worldNorthPole.length();

                // Calculate theta (polar angle) - angle from the positive y-axis
                const theta = Math.acos(worldNorthPole.y / r);

                // Calculate phi (azimuthal angle) - angle around the y-axis from the positive z-axis
                const phi = Math.atan2(worldNorthPole.x, worldNorthPole.z);

                return { theta, phi };
            }

			function updateGroupGeometry( mesh, geometry, distortionScale, size ) {

				mesh.children[ 0 ].geometry.dispose();
				mesh.children[ 1 ].geometry.dispose();
                  
				mesh.children[ 0 ].geometry = new WireframeGeometry( geometry );
				mesh.children[ 1 ].geometry = geometry;

                // for (let i = nearbyTriangles.length - 1; i >= 0; i--) {
                //     const tri = nearbyTriangles[i];
                //     nearbyTriangles.splice(i);
                //     removeTriangle(tri);
                // }


                //console.log(`before - world children: ${world.children.length}`);
                //getNearbyTriangles( distortionScale, size );
                //console.log(`after - world children: ${world.children.length}`);
			}

			const guis = {

                BoxSphere: function ( mesh ) {
                    const data = {
						radius: worldRadius,
						segments: 30,
                        distance: 120,
                        waterDistortionScale: 1,
                        waterSize: 1
					};

					function generateGeometry() {

                        vertDist = data.distance;
                        const boxSphereGeo =    new BoxGeometry(
								data.radius, data.radius, data.radius, data.segments, data.segments, data.segments
							);   
                        const positionAttribute = boxSphereGeo.attributes.position; 
                        // Modify vertices to make them equidistant from the center 
                        for (let i = 0; i < positionAttribute.count; i++) {
                            // Get vertex position
                            const x = positionAttribute.getX(i);
                            const y = positionAttribute.getY(i);
                            const z = positionAttribute.getZ(i);
                            // Calculate distance from the center
                            const length = Math.sqrt(x * x + y * y + z * z);
                            // Normalize and scale to the desired radius
                            const newX = (x / length) * data.radius;
                            const newY = (y / length) * data.radius;
                            const newZ = (z / length) * data.radius;
                            // Update vertex position
                            positionAttribute.setXYZ(i, newX, newY, newZ);
                        } 
                        // Recompute normals for shading
                        boxSphereGeo.computeVertexNormals();
                        
	                    //const numTriangles = boxSphereGeo.index.count / 3; 
                        //console.log(`This geometry has ${numTriangles} triangles.`);

                        //camera.position.y = data.radius + 1;
                        mushPlace = 5;
                        world.position.y = -data.radius;

						updateGroupGeometry( mesh, boxSphereGeo, data.waterDistortionScale, data.waterSize );

					}

					const folder = gui.addFolder( 'BoxSphere' );

					folder.add( data, 'radius', 1, worldRadius*2 ).onChange( generateGeometry );
					folder.add( data, 'segments', 1, 200 ).step( 1 ).onChange( generateGeometry );
					folder.add( data, 'distance', 1, 2000 ).step( 1 ).onChange( generateGeometry );
                    folder.close();

                    const folderWater = gui.addFolder( 'Water' );
                    folderWater.add( data, 'waterDistortionScale', 0, 8, 0.1 ).name( 'distortionScale' ).onChange( generateGeometry );
                    folderWater.add( data, 'waterSize', 0.1, 10, 0.1 ).name( 'size' ).onChange( generateGeometry );
                    folderWater.close();
                    gui.close();

					generateGeometry();

                }

			};

			function chooseFromHash( mesh ) {

				const selectedGeometry = window.location.hash.substring( 1 ) || 'BoxSphere';

				if ( guis[ selectedGeometry ] !== undefined ) {

					guis[ selectedGeometry ]( mesh );

				}

			}

			const selectedGeometry = window.location.hash.substring( 1 );

			if ( guis[ selectedGeometry ] !== undefined ) {

				document.getElementById( 'newWindow' ).href += '#' + selectedGeometry;

			}

			const gui = new GUI();

			const scene = new Scene();
			scene.background = new Color( 0xd0ccff );
            // skybox
            const cubeTextureLoader = new CubeTextureLoader();
            cubeTextureLoader.setPath( './sky/park/' );

            const cubeTexture = cubeTextureLoader.load( [
                'posx.jpg', 'negx.jpg',
                'posy.jpg', 'negy.jpg',
                'posz.jpg', 'negz.jpg'
            ] );
            scene.background = cubeTexture;

			const camera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1500 );
            camera.position.y = 1;

			const renderer = new WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			const lights = [];
			lights[ 0 ] = new DirectionalLight( 0xffffff, 3 );
			lights[ 0 ].position.set( 200, 400, 400 );
			scene.add( lights[ 0 ] );

			const world = new Group();
            let nearbyTriangles = [];

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [], 3 ) );

			const lineMaterial = new LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );
			const meshMaterial = new MeshPhongMaterial( { color: 0x156289, emissive: 0x072534 } );

			world.add( new LineSegments( geometry, lineMaterial ) );
			world.add( new Mesh( geometry, meshMaterial ) );
            world.children[ 0 ].visible = false;
            world.children[ 1 ].visible = false;
            world.position.y = -worldRadius;

            const mushGeo = new BoxGeometry(5,5,5);
            const mush = new Mesh(mushGeo, meshMaterial);
            mush.position.y =  1;
            mush.position.z -= 15;
            let mushPlace = 5;
            scene.add( mush );

			chooseFromHash( world );

            // const yy =  0;
            // const w2xz = 1000;
            // let triangle = { index: -1, verts: [ 
            //         new Vector3(-w2xz, yy, w2xz), // v0
            //         new Vector3(w2xz, yy, w2xz), // v1
            //         new Vector3(-w2xz, yy, -w2xz), // v2
            //         ], needsCreate: true, needsRemove: false, mesh: null, marker: null };
            //         console.log(triangle);
            // drawTriangle(triangle);

            

            // const waterGeometry2 = new BufferGeometry();
            // const vertices = new Float32Array( [
            //     -w2xz, yy, w2xz,
            //     w2xz, yy, w2xz,
            //     -w2xz, yy, -w2xz,

            //     w2xz, yy, w2xz,
            //     w2xz, yy, -w2xz,
            //     -w2xz, yy, -w2xz,

            // ] );
            // waterGeometry2.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
            // waterGeometry2.setAttribute( 'uv', new BufferAttribute( new Float32Array( [0,1,1,1,0,0,1,1,1,0,0,0] ), 2 ));
            // waterGeometry2.computeVertexNormals();
            // const norms = waterGeometry2.getAttribute('normal');
            // const firstNorm = new Vector3(norms.getX(0),norms.getY(0),norms.getZ(0));

            // console.log(`waterGeometry2`, waterGeometry2);
            
            // const water1 = new Water( waterGeometry2, {
            //     color: '#ffffff',
            //     scale: 4,
            //     flowDirection: new Vector2( 1, 1 ),
            //     textureWidth: 1024,
            //     textureHeight: 1024,
            //     normal: firstNorm
            // } );
            // scene.add( water1 );

			scene.add( world );
            initWaterTiles();

            const rotationSpeed = 0.00005;
            const upVector = new Vector3(0, 1, 0);
            const cameraDirection = new Vector3();
            let frameCount = -1;
			function render() {

                if (frameCount == -1) {
                    // okay gotta do some experimenting here because clearly I don't know what I'm doing
                    console.log(`world`, world.children[1]);
                }


				// Turn the camera if the user is turning:
                camera.rotation.y += dirRotate * 0.05;

                // Get the camera's forward direction in world space
                camera.getWorldDirection(cameraDirection);

                // Calculate the 'x' axis relative to the camera 'motion'
                const rotationAxis = new Vector3().crossVectors(cameraDirection, upVector).normalize();

                // Rotate the 'world' under the camera to give the impression of the
                // camera moving around the surface of the world.
                world.rotateOnWorldAxis(rotationAxis, rotationSpeed * dirMove);

                if (frameCount++ == 60) {
                    frameCount = 0;

                    if (dirMove != 0) {
                        //console.log(`Theta: ${sphericalCoords.theta}, Phi: ${sphericalCoords.phi}`);
                        //getNearbyTriangles();
                    }
                }

                // for (let i = 0; i < nearbyTriangles.length; i++) {
                //     let water = nearbyTriangles[i];
                //     water.mesh.material.uniforms[ 'time' ].value += 1.0 / 60.0;
                // }

				const time = performance.now() * 0.001;
                mush.position.y = Math.sin( time ) * 2 + mushPlace-1.5;
                mush.rotation.x = time * 0.5;
                mush.rotation.z = time * 0.51;

				//requestAnimationFrame( render );
				renderer.render( scene, camera );

			}

			window.addEventListener( 'resize', function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}, false );

            let dirRotate = -.025;
            let dirMove = 0;
            window.addEventListener( 'keydown', function( e ) {
                //console.log(`key`,e);
                if (e.code == 'ArrowLeft') {
                    dirRotate = 1;
                } else if (e.code == 'ArrowRight') {
                    dirRotate = -1;
                } else if (e.code == 'ArrowUp') {
                    dirMove = 1;
                } else if (e.code == 'ArrowDown') {
                    dirMove = -1;
                }
            });
            window.addEventListener( 'keyup', function( e ) {
                if (e.code == 'ArrowLeft' || e.code == 'ArrowRight') {
                    dirRotate = 0;
                } else if (e.code == 'ArrowUp' || e.code == 'ArrowDown') {
                    dirMove = 0;
                }
            });

			renderer.setAnimationLoop( render );

            // function animate() {
            //     renderer.render( scene, camera );
            // }
            // renderer.setAnimationLoop( animate );

		</script>
	</body>
</html>