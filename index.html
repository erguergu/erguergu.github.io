<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three JS Random Spheres</title>
    <style>
        /* clear margins, set height, make three js canvas a block element */
        body { margin: 0; height: 100vh; }
        canvas { display: block; }
    </style>
</head>
<body id="threejs">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script>
        function generateCubesOnSphere(numCubes, sphereRadius, cubeSize, pulsePeriodSeconds, pulseMagnitudePercent, planetRotationSpeed) {
  // Set up the scene
  var scene = new THREE.Scene();

  // Set up the camera
  var camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 5;

  // Set up the renderer
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Set up the directional light
  var light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 1, 1);
  scene.add(light);

  // Define an array of bright colors
  var brightColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];

  // Create an array of materials with the bright colors
  var materials = brightColors.map(function(color) {
    return new THREE.MeshPhongMaterial({ color: color, shininess: 30 });
  });

  // Create the cubes and arrange them on a sphere
  var phiIncrement = Math.PI * (3 - Math.sqrt(5)); // Golden angle
  var cubes = [];

  var planet = new THREE.Object3D(); // Parent object for cubes

  for (var i = 0; i < numCubes; i++) {
    var y = 1 - (i / (numCubes - 1)) * 2; // Map to range [-1, 1]

    var radiusAtPhi = Math.sqrt(1 - y * y);
    var theta = i * phiIncrement;

    var x = Math.cos(theta) * radiusAtPhi;
    var z = Math.sin(theta) * radiusAtPhi;

    var cube = new THREE.Mesh(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize), materials[Math.floor(Math.random() * materials.length)]);
    cube.position.set(x, y, z).multiplyScalar(sphereRadius);

    // Generate random rotation speed and direction for each cube
    var rotationSpeed = Math.random() * 0.01 + 0.005; // Random speed between 0.005 and 0.015
    var rotationDirectionX = Math.random() < 0.5 ? -1 : 1; // Random direction -1 or 1
    var rotationDirectionY = Math.random() < 0.5 ? -1 : 1;
    var rotationDirectionZ = Math.random() < 0.5 ? -1 : 1;

    // Store rotation vector in cube's userData
    cube.userData.rotation = new THREE.Vector3(
      rotationSpeed * rotationDirectionX,
      rotationSpeed * rotationDirectionY,
      rotationSpeed * rotationDirectionZ
    );

    planet.add(cube);
    cubes.push(cube);
  }

  scene.add(planet);

  // Animate the cubes and planet rotation
  function animate() {
    requestAnimationFrame(animate);

    // Calculate the pulsating factor based on time and pulsePeriodSeconds
    var pulsateFactor = 1 + Math.sin((Date.now() / (pulsePeriodSeconds * 1000)) * Math.PI * 2);

    // Calculate the distance to move the cubes based on pulsating factor and pulseMagnitudePercent
    var distance = sphereRadius * (pulseMagnitudePercent / 100) * pulsateFactor;

    // Apply the distance to each cube's position
    cubes.forEach(function(cube) {
      cube.position.copy(cube.position.clone().normalize().multiplyScalar(sphereRadius + distance));
    });

    // Rotate each cube on the x, y, and z axes at random speed and direction
    cubes.forEach(function(cube) {
      var rotation = cube.userData.rotation;
      cube.rotation.x += rotation.x;
      cube.rotation.y += rotation.y;
      cube.rotation.z += rotation.z;
    });

    // Rotate the planet about the x-axis
    planet.rotation.x += planetRotationSpeed;

    // Animate the background color
    var hue = (Date.now() / 1000) % 360; // Cycle through hues over time
    var color = new THREE.Color().setHSL(hue / 360, 1, 0.5);
    renderer.setClearColor(color);

    renderer.render(scene, camera);
  }

  animate();
}

// Usage with custom parameters
var numCubes = 4000;
var sphereRadius = 1;
var cubeSize = 0.05;
var pulsePeriodSeconds = 300;
var pulseMagnitudePercent = 100;
var planetRotationSpeed = 0.001;

generateCubesOnSphere(numCubes, sphereRadius, cubeSize, pulsePeriodSeconds, pulseMagnitudePercent, planetRotationSpeed);

    </script>
</body>
</html>
